import { InterviewPhase, ContextualMessage } from '../interview/conversationFlow'
import { InterviewStatus } from './candidateManagement'

export interface InterviewSession {
  id: string
  candidateId: string
  candidateName: string
  position: string
  recruiterId: string
  interviewType: InterviewType
  status: InterviewStatus
  currentPhase: InterviewPhase
  startTime: Date
  endTime?: Date
  estimatedDuration: number
  actualDuration?: number
  progress: InterviewProgress
  phaseHistory: PhaseTransition[]
  realTimeMetrics: RealTimeMetrics
  qualityIndicators: QualityIndicators
  technicalMetrics: TechnicalMetrics
  flags: InterviewFlag[]
  notes: InterviewNote[]
  artifacts: InterviewArtifact[]
}

export interface InterviewProgress {
  overallCompletion: number
  phaseCompletion: { [phase: string]: number }
  objectivesCompleted: string[]
  objectivesRemaining: string[]
  milestones: Milestone[]
  estimatedTimeRemaining: number
  paceIndicator: PaceIndicator
}

export interface PhaseTransition {
  id: string
  fromPhase: InterviewPhase | null
  toPhase: InterviewPhase
  timestamp: Date
  duration: number
  transitionReason: TransitionReason
  quality: TransitionQuality
  automated: boolean
  notes?: string
}

export interface RealTimeMetrics {
  currentEngagement: number
  averageResponseTime: number
  sentimentTrend: SentimentPoint[]
  difficultyProgression: DifficultyPoint[]
  conversationFlow: FlowMetric[]
  lastUpdated: Date
}

export interface QualityIndicators {
  responseClarity: number
  topicRelevance: number
  technicalDepth: number
  communicationQuality: number
  overallQuality: number
  qualityTrend: QualityPoint[]
  concerns: QualityConcern[]
}

export interface TechnicalMetrics {
  systemResponseTime: number
  networkLatency: number
  errorCount: number
  recoveryCount: number
  performanceScore: number
  systemHealth: SystemHealthStatus
  resourceUsage: ResourceUsage
}

export interface InterviewFlag {
  id: string
  type: FlagType
  severity: FlagSeverity
  message: string
  timestamp: Date
  resolved: boolean
  resolvedBy?: string
  resolvedAt?: Date
  autoGenerated: boolean
}

export interface InterviewNote {
  id: string
  authorId: string
  authorName: string
  content: string
  timestamp: Date
  type: NoteType
  phase?: InterviewPhase
  visibility: NoteVisibility
  tags: string[]
}

export interface InterviewArtifact {
  id: string
  type: ArtifactType
  name: string
  description: string
  filePath?: string
  data?: any
  createdAt: Date
  size?: number
  metadata: ArtifactMetadata
}

export interface Milestone {
  id: string
  name: string
  description: string
  targetPhase: InterviewPhase
  completed: boolean
  completedAt?: Date
  importance: MilestoneImportance
  criteria: string[]
}

export interface SentimentPoint {
  timestamp: Date
  sentiment: number
  confidence: number
  phase: InterviewPhase
}

export interface DifficultyPoint {
  timestamp: Date
  difficulty: number
  questionType: string
  candidateResponse: number
}

export interface FlowMetric {
  timestamp: Date
  metric: FlowMetricType
  value: number
  context: string
}

export interface QualityPoint {
  timestamp: Date
  aspect: QualityAspect
  score: number
  details: string
}

export interface QualityConcern {
  id: string
  type: ConcernType
  severity: ConcernSeverity
  description: string
  firstDetected: Date
  lastDetected: Date
  occurrenceCount: number
  phase: InterviewPhase
  resolved: boolean
}

export interface ResourceUsage {
  cpuUsage: number
  memoryUsage: number
  networkBandwidth: number
  responseTime: number
  timestamp: Date
}

export interface ArtifactMetadata {
  format: string
  version: string
  checksum?: string
  compression?: string
  encryption?: boolean
  accessLevel: AccessLevel
}

export interface InterviewStatusUpdate {
  interviewId: string
  timestamp: Date
  oldStatus: InterviewStatus
  newStatus: InterviewStatus
  triggeredBy: UpdateTrigger
  reason?: string
  metadata: UpdateMetadata
}

export interface InterviewStatusSummary {
  scheduled: number
  inProgress: number
  completed: number
  cancelled: number
  noShow: number
  rescheduled: number
  pendingReview: number
  total: number
  activeCount: number
  completionRate: number
  averageDuration: number
}

export interface InterviewDashboardData {
  activeSessions: InterviewSession[]
  statusSummary: InterviewStatusSummary
  recentUpdates: InterviewStatusUpdate[]
  performanceMetrics: DashboardMetrics
  alerts: DashboardAlert[]
  trendsData: TrendsData
}

export interface DashboardMetrics {
  averageSessionDuration: number
  averageQualityScore: number
  systemUptime: number
  throughput: number
  errorRate: number
  userSatisfaction: number
}

export interface DashboardAlert {
  id: string
  type: AlertType
  severity: AlertSeverity
  title: string
  message: string
  timestamp: Date
  affectedInterviews: string[]
  actionRequired: boolean
  autoResolvable: boolean
}

export interface TrendsData {
  interviewVolume: TrendPoint[]
  qualityTrends: TrendPoint[]
  completionRates: TrendPoint[]
  performanceTrends: TrendPoint[]
  timeframe: TimeframePeriod
}

export interface TrendPoint {
  timestamp: Date
  value: number
  label?: string
  metadata?: any
}

export interface UpdateMetadata {
  source: string
  automated: boolean
  confidence: number
  additionalData: any
}

export enum InterviewType {
  PHONE_SCREENING = 'phone_screening',
  VIDEO_INTERVIEW = 'video_interview',
  TECHNICAL_ASSESSMENT = 'technical_assessment',
  BEHAVIORAL_INTERVIEW = 'behavioral_interview',
  FINAL_INTERVIEW = 'final_interview',
  PANEL_INTERVIEW = 'panel_interview'
}

export enum TransitionReason {
  OBJECTIVES_COMPLETED = 'objectives_completed',
  TIME_CONSTRAINT = 'time_constraint',
  CANDIDATE_REQUEST = 'candidate_request',
  QUALITY_CONCERN = 'quality_concern',
  TECHNICAL_ISSUE = 'technical_issue',
  MANUAL_OVERRIDE = 'manual_override',
  AUTOMATIC = 'automatic'
}

export enum TransitionQuality {
  SMOOTH = 'smooth',
  ACCEPTABLE = 'acceptable',
  ABRUPT = 'abrupt',
  POOR = 'poor'
}

export enum PaceIndicator {
  TOO_SLOW = 'too_slow',
  SLOW = 'slow',
  OPTIMAL = 'optimal',
  FAST = 'fast',
  TOO_FAST = 'too_fast'
}

export enum FlagType {
  QUALITY_CONCERN = 'quality_concern',
  TECHNICAL_ISSUE = 'technical_issue',
  ENGAGEMENT_DROP = 'engagement_drop',
  TIME_OVERRUN = 'time_overrun',
  COMPLIANCE_ISSUE = 'compliance_issue',
  CANDIDATE_CONCERN = 'candidate_concern'
}

export enum FlagSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

export enum NoteType {
  OBSERVATION = 'observation',
  CONCERN = 'concern',
  STRENGTH = 'strength',
  ACTION_ITEM = 'action_item',
  DECISION = 'decision',
  FOLLOWUP = 'followup'
}

export enum NoteVisibility {
  PRIVATE = 'private',
  TEAM = 'team',
  PUBLIC = 'public'
}

export enum ArtifactType {
  TRANSCRIPT = 'transcript',
  RECORDING = 'recording',
  SCREEN_CAPTURE = 'screen_capture',
  CODE_SAMPLE = 'code_sample',
  DOCUMENT = 'document',
  REPORT = 'report'
}

export enum MilestoneImportance {
  CRITICAL = 'critical',
  HIGH = 'high',
  MEDIUM = 'medium',
  LOW = 'low'
}

export enum FlowMetricType {
  CONVERSATION_PACE = 'conversation_pace',
  QUESTION_DIFFICULTY = 'question_difficulty',
  RESPONSE_LENGTH = 'response_length',
  TOPIC_TRANSITIONS = 'topic_transitions',
  ENGAGEMENT_LEVEL = 'engagement_level'
}

export enum QualityAspect {
  CLARITY = 'clarity',
  RELEVANCE = 'relevance',
  DEPTH = 'depth',
  COHERENCE = 'coherence',
  ENGAGEMENT = 'engagement'
}

export enum ConcernType {
  COMMUNICATION_ISSUE = 'communication_issue',
  TECHNICAL_DIFFICULTY = 'technical_difficulty',
  ENGAGEMENT_PROBLEM = 'engagement_problem',
  TOPIC_CONFUSION = 'topic_confusion',
  TIME_MANAGEMENT = 'time_management'
}

export enum ConcernSeverity {
  MINOR = 'minor',
  MODERATE = 'moderate',
  MAJOR = 'major',
  CRITICAL = 'critical'
}

export enum SystemHealthStatus {
  EXCELLENT = 'excellent',
  GOOD = 'good',
  FAIR = 'fair',
  POOR = 'poor',
  CRITICAL = 'critical'
}

export enum AccessLevel {
  PUBLIC = 'public',
  INTERNAL = 'internal',
  RESTRICTED = 'restricted',
  CONFIDENTIAL = 'confidential'
}

export enum UpdateTrigger {
  USER_ACTION = 'user_action',
  SYSTEM_AUTOMATIC = 'system_automatic',
  SCHEDULED = 'scheduled',
  API_CALL = 'api_call',
  WEBHOOK = 'webhook'
}

export enum AlertType {
  SYSTEM = 'system',
  QUALITY = 'quality',
  PERFORMANCE = 'performance',
  SECURITY = 'security',
  COMPLIANCE = 'compliance'
}

export enum AlertSeverity {
  INFO = 'info',
  WARNING = 'warning',
  ERROR = 'error',
  CRITICAL = 'critical'
}

export enum TimeframePeriod {
  HOUR = 'hour',
  DAY = 'day',
  WEEK = 'week',
  MONTH = 'month',
  QUARTER = 'quarter',
  YEAR = 'year'
}

export class InterviewTrackingService {
  private activeSessions: Map<string, InterviewSession> = new Map()
  private statusHistory: Map<string, InterviewStatusUpdate[]> = new Map()
  private dashboardSubscribers: Map<string, (data: InterviewDashboardData) => void> = new Map()
  private alertQueue: DashboardAlert[] = []
  private metricsHistory: Map<string, DashboardMetrics[]> = new Map()

  // Real-time tracking methods
  async startInterviewTracking(interviewId: string, candidateId: string, candidateName: string, position: string, recruiterId: string, type: InterviewType): Promise<InterviewSession> {
    const session: InterviewSession = {
      id: interviewId,
      candidateId,
      candidateName,
      position,
      recruiterId,
      interviewType: type,
      status: InterviewStatus.IN_PROGRESS,
      currentPhase: InterviewPhase.INTRODUCTION,
      startTime: new Date(),
      estimatedDuration: this.getEstimatedDuration(type),
      progress: {
        overallCompletion: 0,
        phaseCompletion: {},
        objectivesCompleted: [],
        objectivesRemaining: this.getDefaultObjectives(type),
        milestones: this.getDefaultMilestones(type),
        estimatedTimeRemaining: this.getEstimatedDuration(type),
        paceIndicator: PaceIndicator.OPTIMAL
      },
      phaseHistory: [{
        id: `transition_${Date.now()}`,
        fromPhase: null,
        toPhase: InterviewPhase.INTRODUCTION,
        timestamp: new Date(),
        duration: 0,
        transitionReason: TransitionReason.AUTOMATIC,
        quality: TransitionQuality.SMOOTH,
        automated: true
      }],
      realTimeMetrics: {
        currentEngagement: 0.8,
        averageResponseTime: 0,
        sentimentTrend: [],
        difficultyProgression: [],
        conversationFlow: [],
        lastUpdated: new Date()
      },
      qualityIndicators: {
        responseClarity: 0.8,
        topicRelevance: 0.8,
        technicalDepth: 0.5,
        communicationQuality: 0.8,
        overallQuality: 0.7,
        qualityTrend: [],
        concerns: []
      },
      technicalMetrics: {
        systemResponseTime: 200,
        networkLatency: 50,
        errorCount: 0,
        recoveryCount: 0,
        performanceScore: 0.95,
        systemHealth: SystemHealthStatus.EXCELLENT,
        resourceUsage: {
          cpuUsage: 0.2,
          memoryUsage: 0.3,
          networkBandwidth: 0.1,
          responseTime: 200,
          timestamp: new Date()
        }
      },
      flags: [],
      notes: [],
      artifacts: []
    }

    this.activeSessions.set(interviewId, session)
    await this.updateStatus(interviewId, InterviewStatus.IN_PROGRESS, UpdateTrigger.SYSTEM_AUTOMATIC, 'Interview started')
    
    return session
  }

  async updateInterviewPhase(interviewId: string, newPhase: InterviewPhase, reason: TransitionReason = TransitionReason.AUTOMATIC): Promise<void> {
    const session = this.activeSessions.get(interviewId)
    if (!session) {
      throw new Error(`Interview session ${interviewId} not found`)
    }

    const now = new Date()
    const lastTransition = session.phaseHistory[session.phaseHistory.length - 1]
    const phaseDuration = now.getTime() - lastTransition.timestamp.getTime()

    // Create phase transition record
    const transition: PhaseTransition = {
      id: `transition_${Date.now()}`,
      fromPhase: session.currentPhase,
      toPhase: newPhase,
      timestamp: now,
      duration: phaseDuration,
      transitionReason: reason,
      quality: this.assessTransitionQuality(session, newPhase),
      automated: reason === TransitionReason.AUTOMATIC
    }

    session.phaseHistory.push(transition)
    session.currentPhase = newPhase

    // Update progress
    await this.updateProgress(session)

    // Check for quality concerns
    await this.checkQualityConcerns(session)

    // Notify subscribers
    await this.notifyDashboardUpdate()
  }

  async updateRealTimeMetrics(interviewId: string, metrics: Partial<RealTimeMetrics>): Promise<void> {
    const session = this.activeSessions.get(interviewId)
    if (!session) return

    const now = new Date()

    // Update metrics
    if (metrics.currentEngagement !== undefined) {
      session.realTimeMetrics.currentEngagement = metrics.currentEngagement
      
      // Add to sentiment trend
      session.realTimeMetrics.sentimentTrend.push({
        timestamp: now,
        sentiment: metrics.currentEngagement,
        confidence: 0.8,
        phase: session.currentPhase
      })

      // Keep only last 50 points
      if (session.realTimeMetrics.sentimentTrend.length > 50) {
        session.realTimeMetrics.sentimentTrend.shift()
      }
    }

    if (metrics.averageResponseTime !== undefined) {
      session.realTimeMetrics.averageResponseTime = metrics.averageResponseTime
    }

    session.realTimeMetrics.lastUpdated = now

    // Update pace indicator
    await this.updatePaceIndicator(session)

    // Check for flags
    await this.checkForFlags(session)
  }

  async updateQualityIndicators(interviewId: string, indicators: Partial<QualityIndicators>): Promise<void> {
    const session = this.activeSessions.get(interviewId)
    if (!session) return

    const now = new Date()

    // Update each quality aspect
    Object.keys(indicators).forEach(key => {
      if (key !== 'qualityTrend' && key !== 'concerns' && indicators[key as keyof QualityIndicators] !== undefined) {
        const value = indicators[key as keyof QualityIndicators] as number
        session.qualityIndicators[key as keyof QualityIndicators] = value

        // Add to quality trend
        session.qualityIndicators.qualityTrend.push({
          timestamp: now,
          aspect: key as QualityAspect,
          score: value,
          details: `Updated ${key}`
        })
      }
    })

    // Calculate overall quality
    const qualityAspects = [
      session.qualityIndicators.responseClarity,
      session.qualityIndicators.topicRelevance,
      session.qualityIndicators.technicalDepth,
      session.qualityIndicators.communicationQuality
    ]
    session.qualityIndicators.overallQuality = qualityAspects.reduce((a, b) => a + b, 0) / qualityAspects.length

    // Keep only last 100 quality points
    if (session.qualityIndicators.qualityTrend.length > 100) {
      session.qualityIndicators.qualityTrend.shift()
    }

    // Check for quality concerns
    await this.checkQualityConcerns(session)
  }

  async endInterviewTracking(interviewId: string, finalStatus: InterviewStatus, reason?: string): Promise<InterviewSession> {
    const session = this.activeSessions.get(interviewId)
    if (!session) {
      throw new Error(`Interview session ${interviewId} not found`)
    }

    const endTime = new Date()
    session.endTime = endTime
    session.actualDuration = endTime.getTime() - session.startTime.getTime()
    session.progress.overallCompletion = 1.0

    await this.updateStatus(interviewId, finalStatus, UpdateTrigger.SYSTEM_AUTOMATIC, reason || 'Interview completed')

    // Generate final artifacts
    await this.generateFinalArtifacts(session)

    // Archive the session
    this.activeSessions.delete(interviewId)

    return session
  }

  private async updateProgress(session: InterviewSession): Promise<void> {
    const phaseOrder = [
      InterviewPhase.INTRODUCTION,
      InterviewPhase.BACKGROUND,
      InterviewPhase.TECHNICAL,
      InterviewPhase.BEHAVIORAL,
      InterviewPhase.SITUATIONAL,
      InterviewPhase.COMPANY_FIT,
      InterviewPhase.QUESTIONS,
      InterviewPhase.CONCLUSION
    ]

    const currentPhaseIndex = phaseOrder.indexOf(session.currentPhase)
    const totalPhases = phaseOrder.length

    session.progress.overallCompletion = Math.max(0, (currentPhaseIndex + 1) / totalPhases)

    // Update phase completion
    session.progress.phaseCompletion[session.currentPhase] = 1.0

    // Update estimated time remaining
    const elapsed = Date.now() - session.startTime.getTime()
    const expectedDuration = session.estimatedDuration * 60 * 1000 // Convert to milliseconds
    session.progress.estimatedTimeRemaining = Math.max(0, expectedDuration - elapsed)

    // Update milestones
    session.progress.milestones.forEach(milestone => {
      if (milestone.targetPhase === session.currentPhase && !milestone.completed) {
        milestone.completed = true
        milestone.completedAt = new Date()
        session.progress.objectivesCompleted.push(milestone.name)
      }
    })
  }

  private async updatePaceIndicator(session: InterviewSession): Promise<void> {
    const elapsed = Date.now() - session.startTime.getTime()
    const expectedElapsed = this.getExpectedElapsedTime(session)
    
    const ratio = elapsed / expectedElapsed
    
    if (ratio < 0.8) {
      session.progress.paceIndicator = PaceIndicator.TOO_SLOW
    } else if (ratio < 0.9) {
      session.progress.paceIndicator = PaceIndicator.SLOW
    } else if (ratio < 1.1) {
      session.progress.paceIndicator = PaceIndicator.OPTIMAL
    } else if (ratio < 1.3) {
      session.progress.paceIndicator = PaceIndicator.FAST
    } else {
      session.progress.paceIndicator = PaceIndicator.TOO_FAST
    }
  }

  private async checkForFlags(session: InterviewSession): Promise<void> {
    // Check engagement drop
    if (session.realTimeMetrics.currentEngagement < 0.4) {
      await this.addFlag(session, FlagType.ENGAGEMENT_DROP, FlagSeverity.HIGH, 'Low candidate engagement detected')
    }

    // Check time overrun
    const elapsed = Date.now() - session.startTime.getTime()
    const expectedDuration = session.estimatedDuration * 60 * 1000
    if (elapsed > expectedDuration * 1.2) {
      await this.addFlag(session, FlagType.TIME_OVERRUN, FlagSeverity.MEDIUM, 'Interview running significantly over time')
    }

    // Check quality concerns
    if (session.qualityIndicators.overallQuality < 0.5) {
      await this.addFlag(session, FlagType.QUALITY_CONCERN, FlagSeverity.HIGH, 'Overall interview quality below threshold')
    }

    // Check technical issues
    if (session.technicalMetrics.errorCount > 3) {
      await this.addFlag(session, FlagType.TECHNICAL_ISSUE, FlagSeverity.MEDIUM, 'Multiple technical errors detected')
    }
  }

  private async checkQualityConcerns(session: InterviewSession): Promise<void> {
    const concerns: QualityConcern[] = []

    // Check communication quality
    if (session.qualityIndicators.communicationQuality < 0.6) {
      concerns.push({
        id: `concern_${Date.now()}`,
        type: ConcernType.COMMUNICATION_ISSUE,
        severity: ConcernSeverity.MODERATE,
        description: 'Communication quality below acceptable threshold',
        firstDetected: new Date(),
        lastDetected: new Date(),
        occurrenceCount: 1,
        phase: session.currentPhase,
        resolved: false
      })
    }

    // Check topic relevance
    if (session.qualityIndicators.topicRelevance < 0.5) {
      concerns.push({
        id: `concern_${Date.now()}`,
        type: ConcernType.TOPIC_CONFUSION,
        severity: ConcernSeverity.MAJOR,
        description: 'Responses frequently off-topic or irrelevant',
        firstDetected: new Date(),
        lastDetected: new Date(),
        occurrenceCount: 1,
        phase: session.currentPhase,
        resolved: false
      })
    }

    // Add new concerns
    session.qualityIndicators.concerns.push(...concerns)
  }

  private async addFlag(session: InterviewSession, type: FlagType, severity: FlagSeverity, message: string): Promise<void> {
    // Check if similar flag already exists and is unresolved
    const existingFlag = session.flags.find(f => f.type === type && !f.resolved)
    if (existingFlag) return

    const flag: InterviewFlag = {
      id: `flag_${Date.now()}`,
      type,
      severity,
      message,
      timestamp: new Date(),
      resolved: false,
      autoGenerated: true
    }

    session.flags.push(flag)

    // Create dashboard alert for high/critical flags
    if (severity === FlagSeverity.HIGH || severity === FlagSeverity.CRITICAL) {
      const alert: DashboardAlert = {
        id: `alert_${Date.now()}`,
        type: AlertType.QUALITY,
        severity: severity === FlagSeverity.CRITICAL ? AlertSeverity.CRITICAL : AlertSeverity.WARNING,
        title: `Interview Flag: ${type}`,
        message,
        timestamp: new Date(),
        affectedInterviews: [session.id],
        actionRequired: true,
        autoResolvable: false
      }

      this.alertQueue.push(alert)
    }
  }

  private assessTransitionQuality(session: InterviewSession, newPhase: InterviewPhase): TransitionQuality {
    const currentQuality = session.qualityIndicators.overallQuality
    const engagement = session.realTimeMetrics.currentEngagement

    if (currentQuality > 0.8 && engagement > 0.7) {
      return TransitionQuality.SMOOTH
    } else if (currentQuality > 0.6 && engagement > 0.5) {
      return TransitionQuality.ACCEPTABLE
    } else if (currentQuality > 0.4) {
      return TransitionQuality.ABRUPT
    } else {
      return TransitionQuality.POOR
    }
  }

  private getEstimatedDuration(type: InterviewType): number {
    const durations = {
      [InterviewType.PHONE_SCREENING]: 30,
      [InterviewType.VIDEO_INTERVIEW]: 45,
      [InterviewType.TECHNICAL_ASSESSMENT]: 60,
      [InterviewType.BEHAVIORAL_INTERVIEW]: 45,
      [InterviewType.FINAL_INTERVIEW]: 60,
      [InterviewType.PANEL_INTERVIEW]: 90
    }
    return durations[type] || 45
  }

  private getDefaultObjectives(type: InterviewType): string[] {
    const objectives = {
      [InterviewType.PHONE_SCREENING]: ['Basic qualification check', 'Interest assessment', 'Availability confirmation'],
      [InterviewType.VIDEO_INTERVIEW]: ['Technical skills assessment', 'Communication evaluation', 'Cultural fit check'],
      [InterviewType.TECHNICAL_ASSESSMENT]: ['Coding ability', 'Problem-solving skills', 'Technical knowledge'],
      [InterviewType.BEHAVIORAL_INTERVIEW]: ['Past experience analysis', 'Behavioral patterns', 'Team fit assessment'],
      [InterviewType.FINAL_INTERVIEW]: ['Final qualification', 'Salary discussion', 'Role clarification'],
      [InterviewType.PANEL_INTERVIEW]: ['Multiple perspective assessment', 'Team dynamics', 'Leadership evaluation']
    }
    return objectives[type] || ['General assessment']
  }

  private getDefaultMilestones(type: InterviewType): Milestone[] {
    const baseMilestones: Milestone[] = [
      {
        id: 'intro_complete',
        name: 'Introduction Complete',
        description: 'Candidate introduction and rapport building completed',
        targetPhase: InterviewPhase.INTRODUCTION,
        completed: false,
        importance: MilestoneImportance.MEDIUM,
        criteria: ['Candidate comfortable', 'Basic information gathered']
      },
      {
        id: 'technical_assessed',
        name: 'Technical Skills Assessed',
        description: 'Technical competency evaluation completed',
        targetPhase: InterviewPhase.TECHNICAL,
        completed: false,
        importance: MilestoneImportance.HIGH,
        criteria: ['Technical questions answered', 'Skill level determined']
      }
    ]

    return baseMilestones
  }

  private getExpectedElapsedTime(session: InterviewSession): number {
    const phaseOrder = [
      InterviewPhase.INTRODUCTION,
      InterviewPhase.BACKGROUND,
      InterviewPhase.TECHNICAL,
      InterviewPhase.BEHAVIORAL,
      InterviewPhase.SITUATIONAL,
      InterviewPhase.COMPANY_FIT,
      InterviewPhase.QUESTIONS,
      InterviewPhase.CONCLUSION
    ]

    const currentIndex = phaseOrder.indexOf(session.currentPhase)
    const totalDuration = session.estimatedDuration * 60 * 1000 // Convert to milliseconds
    
    return (currentIndex + 1) / phaseOrder.length * totalDuration
  }

  private async generateFinalArtifacts(session: InterviewSession): Promise<void> {
    // Generate transcript artifact
    const transcriptArtifact: InterviewArtifact = {
      id: `transcript_${session.id}`,
      type: ArtifactType.TRANSCRIPT,
      name: `Interview Transcript - ${session.candidateName}`,
      description: 'Complete interview conversation transcript',
      createdAt: new Date(),
      metadata: {
        format: 'text/plain',
        version: '1.0',
        accessLevel: AccessLevel.INTERNAL
      }
    }

    // Generate interview report
    const reportArtifact: InterviewArtifact = {
      id: `report_${session.id}`,
      type: ArtifactType.REPORT,
      name: `Interview Report - ${session.candidateName}`,
      description: 'Comprehensive interview analysis and recommendations',
      createdAt: new Date(),
      metadata: {
        format: 'application/pdf',
        version: '1.0',
        accessLevel: AccessLevel.INTERNAL
      }
    }

    session.artifacts.push(transcriptArtifact, reportArtifact)
  }

  // Status management
  async updateStatus(interviewId: string, newStatus: InterviewStatus, trigger: UpdateTrigger, reason?: string): Promise<void> {
    const session = this.activeSessions.get(interviewId)
    if (!session) return

    const oldStatus = session.status
    session.status = newStatus

    const statusUpdate: InterviewStatusUpdate = {
      interviewId,
      timestamp: new Date(),
      oldStatus,
      newStatus,
      triggeredBy: trigger,
      reason,
      metadata: {
        source: 'interview_tracking_service',
        automated: trigger === UpdateTrigger.SYSTEM_AUTOMATIC,
        confidence: 1.0,
        additionalData: { sessionPhase: session.currentPhase }
      }
    }

    // Store status history
    if (!this.statusHistory.has(interviewId)) {
      this.statusHistory.set(interviewId, [])
    }
    this.statusHistory.get(interviewId)!.push(statusUpdate)

    // Notify dashboard
    await this.notifyDashboardUpdate()
  }

  // Dashboard data methods
  async getDashboardData(): Promise<InterviewDashboardData> {
    const activeSessions = Array.from(this.activeSessions.values())
    const statusSummary = await this.calculateStatusSummary()
    const recentUpdates = await this.getRecentStatusUpdates(10)
    const performanceMetrics = await this.calculatePerformanceMetrics()
    const alerts = [...this.alertQueue].slice(-20) // Last 20 alerts
    const trendsData = await this.calculateTrendsData()

    return {
      activeSessions,
      statusSummary,
      recentUpdates,
      performanceMetrics,
      alerts,
      trendsData
    }
  }

  private async calculateStatusSummary(): Promise<InterviewStatusSummary> {
    const allSessions = Array.from(this.activeSessions.values())
    
    const statusCounts = {
      scheduled: 0,
      inProgress: 0,
      completed: 0,
      cancelled: 0,
      noShow: 0,
      rescheduled: 0,
      pendingReview: 0
    }

    allSessions.forEach(session => {
      switch (session.status) {
        case InterviewStatus.SCHEDULED:
          statusCounts.scheduled++
          break
        case InterviewStatus.IN_PROGRESS:
          statusCounts.inProgress++
          break
        case InterviewStatus.COMPLETED:
          statusCounts.completed++
          break
        case InterviewStatus.CANCELLED:
          statusCounts.cancelled++
          break
        case InterviewStatus.NO_SHOW:
          statusCounts.noShow++
          break
        case InterviewStatus.RESCHEDULED:
          statusCounts.rescheduled++
          break
        case InterviewStatus.PENDING_REVIEW:
          statusCounts.pendingReview++
          break
      }
    })

    const total = allSessions.length
    const activeCount = statusCounts.scheduled + statusCounts.inProgress
    const completionRate = total > 0 ? statusCounts.completed / total : 0
    
    const completedSessions = allSessions.filter(s => s.actualDuration)
    const averageDuration = completedSessions.length > 0 
      ? completedSessions.reduce((sum, s) => sum + (s.actualDuration || 0), 0) / completedSessions.length / 60000 // Convert to minutes
      : 0

    return {
      ...statusCounts,
      total,
      activeCount,
      completionRate,
      averageDuration
    }
  }

  private async getRecentStatusUpdates(limit: number): Promise<InterviewStatusUpdate[]> {
    const allUpdates: InterviewStatusUpdate[] = []
    
    this.statusHistory.forEach(history => {
      allUpdates.push(...history)
    })

    return allUpdates
      .sort((a, b) => b.timestamp.getTime() - a.timestamp.getTime())
      .slice(0, limit)
  }

  private async calculatePerformanceMetrics(): Promise<DashboardMetrics> {
    const sessions = Array.from(this.activeSessions.values())
    
    const averageSessionDuration = sessions.length > 0
      ? sessions.reduce((sum, s) => sum + (s.actualDuration || (Date.now() - s.startTime.getTime())), 0) / sessions.length / 60000
      : 0

    const averageQualityScore = sessions.length > 0
      ? sessions.reduce((sum, s) => sum + s.qualityIndicators.overallQuality, 0) / sessions.length
      : 0

    const totalErrors = sessions.reduce((sum, s) => sum + s.technicalMetrics.errorCount, 0)
    const errorRate = sessions.length > 0 ? totalErrors / sessions.length : 0

    const averagePerformanceScore = sessions.length > 0
      ? sessions.reduce((sum, s) => sum + s.technicalMetrics.performanceScore, 0) / sessions.length
      : 0

    return {
      averageSessionDuration,
      averageQualityScore,
      systemUptime: 0.99, // Would be calculated from actual system metrics
      throughput: sessions.length, // Sessions per hour would be more accurate
      errorRate,
      userSatisfaction: averagePerformanceScore
    }
  }

  private async calculateTrendsData(): Promise<TrendsData> {
    const now = new Date()
    const timeframe = TimeframePeriod.DAY
    
    // Mock trend data - in real implementation, this would query historical data
    const interviewVolume: TrendPoint[] = []
    const qualityTrends: TrendPoint[] = []
    const completionRates: TrendPoint[] = []
    const performanceTrends: TrendPoint[] = []

    // Generate last 24 hours of data points
    for (let i = 23; i >= 0; i--) {
      const timestamp = new Date(now.getTime() - i * 60 * 60 * 1000)
      
      interviewVolume.push({
        timestamp,
        value: Math.floor(Math.random() * 10) + 1,
        label: `${timestamp.getHours()}:00`
      })

      qualityTrends.push({
        timestamp,
        value: Math.random() * 0.3 + 0.7, // 0.7 to 1.0
        label: `${timestamp.getHours()}:00`
      })

      completionRates.push({
        timestamp,
        value: Math.random() * 0.2 + 0.8, // 0.8 to 1.0
        label: `${timestamp.getHours()}:00`
      })

      performanceTrends.push({
        timestamp,
        value: Math.random() * 0.1 + 0.9, // 0.9 to 1.0
        label: `${timestamp.getHours()}:00`
      })
    }

    return {
      interviewVolume,
      qualityTrends,
      completionRates,
      performanceTrends,
      timeframe
    }
  }

  // Real-time notifications
  subscribeToDashboard(subscriberId: string, callback: (data: InterviewDashboardData) => void): void {
    this.dashboardSubscribers.set(subscriberId, callback)
  }

  unsubscribeFromDashboard(subscriberId: string): void {
    this.dashboardSubscribers.delete(subscriberId)
  }

  private async notifyDashboardUpdate(): Promise<void> {
    const dashboardData = await this.getDashboardData()
    
    this.dashboardSubscribers.forEach(callback => {
      try {
        callback(dashboardData)
      } catch (error) {
        console.error('Error notifying dashboard subscriber:', error)
      }
    })
  }

  // Utility methods
  async getInterviewSession(interviewId: string): Promise<InterviewSession | null> {
    return this.activeSessions.get(interviewId) || null
  }

  async getStatusHistory(interviewId: string): Promise<InterviewStatusUpdate[]> {
    return this.statusHistory.get(interviewId) || []
  }

  async addInterviewNote(interviewId: string, note: InterviewNote): Promise<void> {
    const session = this.activeSessions.get(interviewId)
    if (session) {
      session.notes.push(note)
      await this.notifyDashboardUpdate()
    }
  }

  async resolveFlag(interviewId: string, flagId: string, resolvedBy: string): Promise<void> {
    const session = this.activeSessions.get(interviewId)
    if (session) {
      const flag = session.flags.find(f => f.id === flagId)
      if (flag) {
        flag.resolved = true
        flag.resolvedBy = resolvedBy
        flag.resolvedAt = new Date()
      }
    }
  }

  async dismissAlert(alertId: string): Promise<void> {
    const index = this.alertQueue.findIndex(alert => alert.id === alertId)
    if (index > -1) {
      this.alertQueue.splice(index, 1)
      await this.notifyDashboardUpdate()
    }
  }

  // Cleanup methods
  async cleanupCompletedSessions(olderThanHours: number = 24): Promise<number> {
    const cutoffTime = new Date(Date.now() - olderThanHours * 60 * 60 * 1000)
    let cleaned = 0

    // This would typically move completed sessions to long-term storage
    // For now, we just remove them from active tracking
    this.activeSessions.forEach((session, id) => {
      if (session.endTime && session.endTime < cutoffTime) {
        this.activeSessions.delete(id)
        cleaned++
      }
    })

    return cleaned
  }
}

// Singleton instance
export const interviewTrackingService = new InterviewTrackingService()